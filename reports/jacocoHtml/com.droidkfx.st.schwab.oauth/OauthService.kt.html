<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
    <link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/>
    <link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/>
    <title>OauthService.kt</title>
    <link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/>
    <script type="text/javascript" src="../jacoco-resources/prettify.js"></script>
</head>
<body onload="window['PR_TAB_WIDTH']=4;prettyPrint()">
<div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html"
                                                              class="el_session">Sessions</a></span><a
        href="../index.html" class="el_report">schwab-trader</a> &gt; <a href="index.source.html" class="el_package">com.droidkfx.st.schwab.oauth</a>
    &gt; <span class="el_source">OauthService.kt</span></div>
<h1>OauthService.kt</h1>
<pre class="source lang-java linenums">package com.droidkfx.st.schwab.oauth

import com.droidkfx.st.schwab.client.OauthClient
import com.droidkfx.st.schwab.client.OauthTokenResponse
import com.droidkfx.st.util.databind.ReadOnlyValueDataBinding
import com.droidkfx.st.util.databind.ValueDataBinding
import com.droidkfx.st.util.databind.readOnly
import io.github.oshai.kotlinlogging.KotlinLogging.logger
import kotlinx.coroutines.TimeoutCancellationException
import kotlinx.coroutines.runBlocking
import kotlinx.coroutines.withTimeout
import java.time.Instant

<span class="nc" id="L14">class OauthService(</span>
<span class="nc" id="L15">    val repo: OauthRepository,</span>
<span class="nc" id="L16">    val client: OauthClient,</span>
<span class="nc" id="L17">    val server: LocalServer,</span>
<span class="nc" id="L18">    val tokenStatus: ValueDataBinding&lt;OauthStatus&gt;,</span>
<span class="nc" id="L19">    val authToken: ValueDataBinding&lt;String?&gt; = ValueDataBinding(null),</span>
    tokenRefreshSignal: ValueDataBinding&lt;Boolean&gt;
<span class="nc" id="L21">) {</span>
<span class="nc" id="L22">    private val logger = logger {}</span>
<span class="nc" id="L23">    private var existingToken: OauthTokenResponse? = obtainAuth(doInit = false, allowRefresh = false)</span>
        set(value) {
<span class="nc" id="L25">            field = value</span>
<span class="nc bnc" id="L26" title="All 2 branches missed.">            authToken.value = value?.accessToken</span>
<span class="nc" id="L27">        }</span>

<span class="nc" id="L29">    init {</span>
<span class="nc" id="L30">        tokenRefreshSignal.addListener {</span>
<span class="nc" id="L31">            refreshToken()</span>
<span class="nc" id="L32">        }</span>
<span class="nc" id="L33">    }</span>

<span class="nc"
      id="L35">    fun getStatus(): ReadOnlyValueDataBinding&lt;OauthStatus&gt; = tokenStatus.readOnly()</span>

<span class="nc" id="L37">    fun obtainAuth(doInit: Boolean = true, allowRefresh: Boolean = true): OauthTokenResponse? {</span>
<span class="nc" id="L38">        logger.trace { &quot;obtainAuth&quot; }</span>
        // Load existing token from the file
<span class="nc bnc" id="L40" title="All 2 branches missed.">        if (existingToken == null) {</span>
<span class="nc" id="L41">            existingToken = repo.loadExistingToken()</span>
        }
        // If an existing token is expired, try to refresh it
<span class="nc bnc" id="L44" title="All 10 branches missed.">        if (allowRefresh &amp;&amp; existingToken?.expiresAt?.isBefore(Instant.now()) == true) {</span>
<span class="nc" id="L45">            refreshToken()</span>
        }
        // If no existing token, try to get one by Oauth
<span class="nc bnc" id="L48"
      title="All 4 branches missed.">        if (existingToken == null &amp;&amp; doInit) {</span>
<span class="nc" id="L49">            logger.debug { &quot;token found, trying to obtain one&quot; }</span>
<span class="nc" id="L50">            existingToken = runInitialAuthorization()</span>
<span class="nc bnc" id="L51" title="All 2 branches missed.">                ?.apply { repo.saveToken(this) }</span>
        }
<span class="nc" id="L53">        return updateTokenStatus()</span>
    }

<span class="nc bnc" id="L56" title="All 2 branches missed.">    private fun updateTokenStatus(): OauthTokenResponse? = existingToken?.apply {</span>
<span class="nc bnc" id="L57" title="All 4 branches missed.">        tokenStatus.value = if (expiresAt?.isAfter(Instant.now()) ?: false) {</span>
<span class="nc" id="L58">            logger.info { &quot;token is valid&quot; }</span>
<span class="nc" id="L59">            OauthStatus.READY</span>
        } else {
<span class="nc" id="L61">            logger.info { &quot;token is expired&quot; }</span>
<span class="nc" id="L62">            OauthStatus.EXPIRED</span>
        }
<span class="nc" id="L64">    } ?: run {</span>
<span class="nc" id="L65">        logger.info { &quot;token is not initialized&quot; }</span>
<span class="nc" id="L66">        tokenStatus.value = OauthStatus.NOT_INITIALIZED</span>
<span class="nc" id="L67">        null</span>
<span class="nc" id="L68">    }</span>

    private fun refreshToken() {
<span class="nc" id="L71">        logger.debug { &quot;refreshToken&quot; }</span>
<span class="nc" id="L72">        tokenStatus.value = OauthStatus.INITIALIZING</span>
<span class="nc" id="L73">        try {</span>
<span class="nc bnc" id="L74"
      title="All 2 branches missed.">            existingToken = existingToken?.refreshToken</span>
<span class="nc bnc" id="L75" title="All 2 branches missed.">                ?.let { client.refreshOauth(it) }</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">                ?.apply { repo.saveToken(this) }</span>
<span class="nc" id="L77">        } catch (e: Exception) {</span>
<span class="nc" id="L78">            logger.error { &quot;Error refreshing token ${e.message}&quot; }</span>
<span class="nc" id="L79">            repo.deleteToken()</span>
<span class="nc" id="L80">            existingToken = null</span>
        }
<span class="nc" id="L82">        updateTokenStatus()</span>
<span class="nc" id="L83">    }</span>

    fun invalidateOauth() {
<span class="nc" id="L86">        logger.trace { &quot;invalidateOauth&quot; }</span>
<span class="nc" id="L87">        repo.deleteToken()</span>
<span class="nc" id="L88">        existingToken = null</span>
<span class="nc" id="L89">        tokenStatus.value = OauthStatus.NOT_INITIALIZED</span>
<span class="nc" id="L90">    }</span>

<span class="nc" id="L92">    fun getTokenStatusBinding() = tokenStatus.readOnly()</span>

    private fun runInitialAuthorization(): OauthTokenResponse? {
<span class="nc" id="L95">        logger.trace { &quot;runInitialAuthorization&quot; }</span>
<span class="nc" id="L96">        existingToken = runBlocking {</span>
<span class="nc" id="L97">            logger.info { &quot;Beginning Oauth flow&quot; }</span>
<span class="nc" id="L98">            tokenStatus.value = OauthStatus.INITIALIZING</span>
<span class="nc" id="L99">            val resultDeferred = server.awaitReponse()</span>

<span class="nc" id="L101">            val requestState = client.triggerOauthFlow()</span>

<span class="nc" id="L103">            val result: LocalServer.Result = try {</span>
<span class="nc" id="L104">                withTimeout(30_000) {</span>
<span class="nc" id="L105">                    resultDeferred.await()</span>
                }
<span class="nc" id="L107">            } catch (_: TimeoutCancellationException) {</span>
<span class="nc" id="L108">                logger.error { &quot;Timeout waiting for server response&quot; }</span>
<span class="nc" id="L109">                server.stop()</span>
<span class="nc" id="L110">                return@runBlocking null</span>
            }

<span class="nc bnc" id="L113" title="All 2 branches missed.">            if (result.error != null) {</span>
<span class="nc" id="L114">                logger.error { &quot;Error: ${result.error}&quot; }</span>
<span class="nc" id="L115">                throw RuntimeException(&quot;Error: ${result.error}&quot;)</span>
<span class="nc bnc" id="L116" title="All 2 branches missed.">            } else if (result.code != null) {</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">                if (result.state != requestState) {</span>
<span class="nc" id="L118">                    logger.error { &quot;State mismatch, expected ${requestState}, got ${result.state} - aborting&quot; }</span>
<span class="nc" id="L119">                    throw IllegalStateException(&quot;State mismatch&quot;)</span>
                }
<span class="nc" id="L121">                val token = client.exchangeOauthToken(result)</span>
<span class="nc" id="L122">                return@runBlocking token</span>
            } else {
<span class="nc"
      id="L124">                logger.error { &quot;Unexpected result both code and error are null&quot; }</span>
<span class="nc" id="L125">                throw IllegalStateException(&quot;Unexpected result&quot;)</span>
            }
        }
<span class="nc" id="L128">        return existingToken</span>
    }
}
</pre>
<div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span>
</div>
</body>
</html>