<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
    <link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/>
    <link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/>
    <title>ListDataBinding.kt</title>
    <link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/>
    <script type="text/javascript" src="../jacoco-resources/prettify.js"></script>
</head>
<body onload="window['PR_TAB_WIDTH']=4;prettyPrint()">
<div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html"
                                                              class="el_session">Sessions</a></span><a
        href="../index.html" class="el_report">schwab-trader</a> &gt; <a href="index.source.html" class="el_package">com.droidkfx.st.util.databind</a>
    &gt; <span class="el_source">ListDataBinding.kt</span></div>
<h1>ListDataBinding.kt</h1>
<pre class="source lang-java linenums">package com.droidkfx.st.util.databind

interface ListDataBinding&lt;T&gt; {
    fun addListener(listener: (ListDataBindingEvent&lt;T&gt;) -&gt; Unit)
}

interface ReadOnlyListDataBinding&lt;T&gt; : List&lt;T&gt;, ListDataBinding&lt;T&gt;

interface ReadWriteListDataBinding&lt;T&gt; : MutableList&lt;T&gt;, ListDataBinding&lt;T&gt;

enum class ListDataBindingEventType {
<span class="nc" id="L12">    ADD, REMOVE, UPDATE</span>
}

<span class="nc" id="L15">class ValueUpdatedListDataBindingEvent&lt;T&gt;(</span>
    index: Int,
    currentValue: T,
<span class="nc" id="L18">    val previousValue: T</span>
<span class="nc"
      id="L19">) : ListDataBindingEvent&lt;T&gt;(index, currentValue, ListDataBindingEventType.UPDATE) {</span>
<span class="nc bnc" id="L20" title="All 2 branches missed.">    val shouldEmit = currentValue != previousValue</span>

    override fun &lt;U&gt; mapped(mapper: (T) -&gt; U): ValueUpdatedListDataBindingEvent&lt;U&gt; {
<span class="nc" id="L23">        return ValueUpdatedListDataBindingEvent(index, mapper(currentValue), mapper(previousValue))</span>
    }
}

<span class="nc" id="L27">open class ListDataBindingEvent&lt;T&gt;(val index: Int, val currentValue: T, val type: ListDataBindingEventType) {</span>
    open fun &lt;U&gt; mapped(mapper: (T) -&gt; U): ListDataBindingEvent&lt;U&gt; {
<span class="nc" id="L29">        return ListDataBindingEvent(index, mapper(currentValue), type)</span>
    }
}

<span class="nc" id="L33">fun &lt;T&gt; List&lt;T&gt;.toDataBinding(): ReadOnlyListDataBinding&lt;T&gt; = ReadOnlyListDataBindingImpl(this)</span>

<span class="nc" id="L35">fun &lt;T&gt; MutableList&lt;T&gt;.toDataBinding(): ReadWriteListDataBinding&lt;T&gt; = ReadWriteListDataBindingImpl(this)</span>

<span class="nc" id="L37">fun &lt;T&gt; ReadWriteListDataBinding&lt;T&gt;.readOnly(): ReadOnlyListDataBinding&lt;T&gt; = ReadOnlyListDataBindingImpl(this)</span>

fun &lt;T, U&gt; ReadWriteListDataBinding&lt;T&gt;.mapped(mapper: (T) -&gt; U): ReadOnlyListDataBinding&lt;U&gt; =
<span class="nc" id="L40">    MappedListDataBinding(readOnly(), mapper)</span>

fun &lt;T, U&gt; ReadOnlyListDataBinding&lt;T&gt;.mapped(mapper: (T) -&gt; U): ReadOnlyListDataBinding&lt;U&gt; =
<span class="nc" id="L43">    MappedListDataBinding(this, mapper)</span>

<span class="nc" id="L45">private class MappedListDataBinding&lt;T, U&gt;(</span>
<span class="nc" id="L46">    private val delegate: ReadOnlyListDataBinding&lt;T&gt;,</span>
<span class="nc" id="L47">    private val mapper: (T) -&gt; U</span>
) : ReadOnlyListDataBinding&lt;U&gt; {
    override val size: Int
<span class="nc" id="L50">        get() = delegate.size</span>

<span class="nc" id="L52">    override fun isEmpty(): Boolean = delegate.isEmpty()</span>

<span class="nc" id="L54">    override fun contains(element: U): Boolean = delegate.any { mapper(it) == element }</span>

<span class="nc" id="L56">    override fun iterator(): Iterator&lt;U&gt; = delegate.stream().map { mapper(it) }.iterator()</span>

<span class="nc" id="L58">    override fun containsAll(elements: Collection&lt;U&gt;): Boolean = elements.all { contains(it) }</span>

<span class="nc" id="L60">    override fun get(index: Int): U = mapper(delegate[index])</span>

<span class="nc"
      id="L62">    override fun indexOf(element: U): Int = delegate.indexOfFirst { mapper(it) == element }</span>

<span class="nc"
      id="L64">    override fun lastIndexOf(element: U): Int = delegate.indexOfLast { mapper(it) == element }</span>

<span class="nc" id="L66">    override fun listIterator(): ListIterator&lt;U&gt; = throw UnsupportedOperationException(&quot;Not yet implemented&quot;)</span>

<span class="nc" id="L68">    override fun listIterator(index: Int): ListIterator&lt;U&gt; = throw UnsupportedOperationException(&quot;Not yet implemented&quot;)</span>

    override fun subList(fromIndex: Int, toIndex: Int): List&lt;U&gt; =
<span class="nc" id="L71">        throw UnsupportedOperationException(&quot;Not yet implemented&quot;)</span>

    override fun addListener(listener: (ListDataBindingEvent&lt;U&gt;) -&gt; Unit) {
<span class="nc" id="L74">        delegate.addListener {</span>
<span class="nc" id="L75">            val mappedEvent = it.mapped(mapper)</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">            if (mappedEvent is ValueUpdatedListDataBindingEvent) {</span>
<span class="nc bnc" id="L77" title="All 2 branches missed.">                if (mappedEvent.shouldEmit) {</span>
<span class="nc" id="L78">                    listener(mappedEvent)</span>
                }
            } else {
<span class="nc" id="L81">                listener(mappedEvent)</span>
            }
<span class="nc" id="L83">        }</span>
<span class="nc" id="L84">    }</span>
}

<span class="nc"
      id="L87">private open class ReadOnlyListDataBindingImpl&lt;T&gt;(open val delegate: List&lt;T&gt;) :</span>
    ReadOnlyListDataBinding&lt;T&gt; {
<span class="nc" id="L89">    protected val listeners = mutableListOf&lt;(ListDataBindingEvent&lt;T&gt;) -&gt; Unit&gt;()</span>

<span class="nc" id="L91">    override fun listIterator(): ListIterator&lt;T&gt; = delegate.listIterator()</span>

<span class="nc" id="L93">    override fun listIterator(index: Int): ListIterator&lt;T&gt; = delegate.listIterator(index)</span>

    override fun subList(fromIndex: Int, toIndex: Int): MutableList&lt;T&gt; {
<span class="nc" id="L96">        throw UnsupportedOperationException(&quot;Sublist is not supported&quot;)</span>
    }

    override val size: Int
<span class="nc" id="L100">        get() = delegate.size</span>

<span class="nc" id="L102">    override fun isEmpty(): Boolean = delegate.isEmpty()</span>

<span class="nc" id="L104">    override fun contains(element: T): Boolean = delegate.contains(element)</span>

<span class="nc" id="L106">    override fun containsAll(elements: Collection&lt;T&gt;): Boolean = delegate.containsAll(elements)</span>

<span class="nc" id="L108">    override fun get(index: Int): T = delegate[index]</span>

<span class="nc" id="L110">    override fun indexOf(element: T): Int = delegate.indexOf(element)</span>

<span class="nc" id="L112">    override fun lastIndexOf(element: T): Int = delegate.lastIndexOf(element)</span>

<span class="nc" id="L114">    override fun iterator(): Iterator&lt;T&gt; = delegate.iterator()</span>

    override fun addListener(listener: (ListDataBindingEvent&lt;T&gt;) -&gt; Unit) {
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (delegate is ReadOnlyListDataBinding&lt;T&gt;) {</span>
<span class="nc" id="L118">            (delegate as ReadOnlyListDataBinding&lt;T&gt;).addListener(listener)</span>
        } else {
<span class="nc" id="L120">            listeners.add(listener)</span>
        }
<span class="nc" id="L122">    }</span>
}

<span class="nc"
      id="L125">private class ReadWriteListDataBindingImpl&lt;T&gt;(val delegate: MutableList&lt;T&gt;) :</span>
    ReadWriteListDataBinding&lt;T&gt;,
    ReadOnlyListDataBinding&lt;T&gt; {
<span class="nc"
      id="L128">    private val listeners = mutableListOf&lt;(ListDataBindingEvent&lt;T&gt;) -&gt; Unit&gt;()</span>
    override fun add(element: T): Boolean {
<span class="nc" id="L130">        val retValue = delegate.add(element)</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">        if (retValue) {</span>
<span class="nc" id="L132">            listeners.forEach { it(ListDataBindingEvent(size - 1, element, ListDataBindingEventType.ADD)) }</span>
        }
<span class="nc" id="L134">        return retValue</span>
    }

    override fun remove(element: T): Boolean {
<span class="nc" id="L138">        val index = delegate.indexOf(element)</span>
<span class="nc" id="L139">        val retValue = delegate.remove(element)</span>
<span class="nc bnc" id="L140" title="All 2 branches missed.">        if (retValue) {</span>
<span class="nc" id="L141">            listeners.forEach {</span>
<span class="nc"
      id="L142">                it(ListDataBindingEvent(index, element, ListDataBindingEventType.REMOVE))</span>
<span class="nc" id="L143">            }</span>
        }
<span class="nc" id="L145">        return retValue</span>
    }

<span class="nc" id="L148">    override fun addAll(elements: Collection&lt;T&gt;): Boolean = elements.map { add(it) }.any { it }</span>

    override fun addAll(index: Int, elements: Collection&lt;T&gt;): Boolean {
<span class="nc" id="L151">        val retValue = delegate.addAll(index, elements)</span>
<span class="nc bnc" id="L152" title="All 2 branches missed.">        if (retValue) {</span>
<span class="nc" id="L153">            elements.forEachIndexed { elemIndex, element -&gt;</span>
<span class="nc" id="L154">                listeners.forEach { it(ListDataBindingEvent(index + elemIndex, element, ListDataBindingEventType.ADD)) }</span>
<span class="nc" id="L155">            }</span>
        }
<span class="nc" id="L157">        return retValue</span>
    }

<span class="nc" id="L160">    override fun removeAll(elements: Collection&lt;T&gt;): Boolean = elements.map { remove(it) }.any { it }</span>

    override fun retainAll(elements: Collection&lt;T&gt;): Boolean {
<span class="nc" id="L163">        return delegate.removeAll(delegate.filter {</span>
<span class="nc bnc" id="L164" title="All 2 branches missed.">            !elements.contains(it)</span>
        })
    }

    override fun clear() {
<span class="nc bnc" id="L169" title="All 4 branches missed.">        while (delegate.isNotEmpty()) {</span>
<span class="nc" id="L170">            removeAt(0)</span>
        }
<span class="nc" id="L172">    }</span>

    override fun set(index: Int, element: T): T {
<span class="nc" id="L175">        val retValue = delegate.set(index, element)</span>
<span class="nc"
      id="L176">        listeners.forEach { it(ValueUpdatedListDataBindingEvent(index, element, retValue)) }</span>
<span class="nc" id="L177">        return retValue</span>
    }

    override fun add(index: Int, element: T) {
<span class="nc" id="L181">        val retValue = delegate.add(index, element)</span>
<span class="nc" id="L182">        listeners.forEach { it(ListDataBindingEvent(index, element, ListDataBindingEventType.ADD)) }</span>
<span class="nc" id="L183">        return retValue</span>
    }

    override fun removeAt(index: Int): T {
<span class="nc" id="L187">        val retValue = delegate.removeAt(index)</span>
<span class="nc" id="L188">        listeners.forEach { it(ListDataBindingEvent(index, retValue, ListDataBindingEventType.REMOVE)) }</span>
<span class="nc" id="L189">        return retValue</span>
    }

<span class="nc"
      id="L192">    override fun listIterator(): MutableListIterator&lt;T&gt; = delegate.listIterator()</span>

<span class="nc" id="L194">    override fun listIterator(index: Int): MutableListIterator&lt;T&gt; = delegate.listIterator(index)</span>

    override fun subList(fromIndex: Int, toIndex: Int): MutableList&lt;T&gt; {
<span class="nc" id="L197">        throw UnsupportedOperationException(&quot;Sublist is not supported&quot;)</span>
    }

    override val size: Int
<span class="nc" id="L201">        get() = delegate.size</span>

<span class="nc" id="L203">    override fun isEmpty(): Boolean = delegate.isEmpty()</span>

<span class="nc" id="L205">    override fun contains(element: T): Boolean = delegate.contains(element)</span>

<span class="nc" id="L207">    override fun containsAll(elements: Collection&lt;T&gt;): Boolean = delegate.containsAll(elements)</span>

<span class="nc" id="L209">    override fun get(index: Int): T = delegate[index]</span>

<span class="nc" id="L211">    override fun indexOf(element: T): Int = delegate.indexOf(element)</span>

<span class="nc" id="L213">    override fun lastIndexOf(element: T): Int = delegate.lastIndexOf(element)</span>

<span class="nc" id="L215">    override fun iterator(): MutableIterator&lt;T&gt; = delegate.iterator()</span>

    override fun addListener(listener: (ListDataBindingEvent&lt;T&gt;) -&gt; Unit) {
<span class="nc" id="L218">        listeners.add(listener)</span>
<span class="nc" id="L219">    }</span>
}
</pre>
<div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span>
</div>
</body>
</html>