<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
<head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
    <link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/>
    <link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/>
    <title>ObjectTableModel.kt</title>
    <link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/>
    <script type="text/javascript" src="../jacoco-resources/prettify.js"></script>
</head>
<body onload="window['PR_TAB_WIDTH']=4;prettyPrint()">
<div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html"
                                                              class="el_session">Sessions</a></span><a
        href="../index.html" class="el_report">schwab-trader</a> &gt; <a href="index.source.html" class="el_package">com.droidkfx.st.view.model</a>
    &gt; <span class="el_source">ObjectTableModel.kt</span></div>
<h1>ObjectTableModel.kt</h1>
<pre class="source lang-java linenums">package com.droidkfx.st.view.model

import java.lang.reflect.Method
import java.lang.reflect.Modifier
import java.math.BigDecimal
import java.util.Locale.getDefault
import javax.swing.table.AbstractTableModel
import kotlin.reflect.KClass

interface ReadTableValueMapper {
    fun mapOut(value: Any): String
}

interface ReadWriteTableValueMapper : ReadTableValueMapper {
    fun mapIn(value: String): Any
}

<span class="nc" id="L18">open class DefaultReadTableValueMapper : ReadWriteTableValueMapper {</span>
    override fun mapOut(value: Any): String {
<span class="nc" id="L20">        return value.toString()</span>
    }

    override fun mapIn(value: String): String {
<span class="nc" id="L24">        return value</span>
    }
}

<span class="nc" id="L28">open class BigDecimalReadTableValueMapper(private val format: String = &quot;%.2f&quot;) : ReadWriteTableValueMapper {</span>
    override fun mapOut(value: Any): String {
<span class="nc bnc" id="L30" title="All 2 branches missed.">        if (value !is BigDecimal) {</span>
<span class="nc" id="L31">            return &quot;&quot;</span>
        }
<span class="nc bnc" id="L33" title="All 2 branches missed.">        if (value == BigDecimal.ZERO) {</span>
<span class="nc" id="L34">            return &quot;-&quot;</span>
        }
<span class="nc" id="L36">        return format.format(value)</span>
    }

    override fun mapIn(value: String): BigDecimal {
<span class="nc bnc" id="L40"
      title="All 2 branches missed.">        return BigDecimal(value.toDoubleOrNull() ?: 0.0)</span>
    }
}

<span class="nc" id="L44">class DollarReadTableValueMapper : BigDecimalReadTableValueMapper() {</span>
    override fun mapOut(value: Any): String {
<span class="nc" id="L46">        return &quot;$ &quot; + super.mapOut(value)</span>
    }

    override fun mapIn(value: String): BigDecimal {
<span class="nc" id="L50">        return super.mapIn(value.replace(&quot;$ &quot;, &quot;&quot;))</span>
    }
}

<span class="nc"
      id="L54">class PercentReadTableValueMapper : BigDecimalReadTableValueMapper(&quot;%05.2f&quot;) {</span>
    override fun mapOut(value: Any): String {
<span class="nc" id="L56">        return super.mapOut(value) + &quot; %&quot;</span>
    }

    override fun mapIn(value: String): BigDecimal {
<span class="nc" id="L60">        return super.mapIn(value.replace(&quot; %&quot;, &quot;&quot;))</span>
    }
}

annotation class Column(
    val name: String = &quot;&quot;,
    val position: Int = -1,
    val mapper: KClass&lt;out ReadTableValueMapper&gt; = DefaultReadTableValueMapper::class,
    val editable: Boolean = true
)

<span class="nc" id="L71">open class ObjectTableModel&lt;T&gt;(</span>
<span class="nc" id="L72">    private val data: List&lt;T&gt;, private val typeInfo: Class&lt;T&gt;</span>
) : AbstractTableModel() {

<span class="nc" id="L75">    protected val columns = typeInfo.declaredFields</span>
<span class="nc bnc" id="L76" title="All 2 branches missed.">        .filter { it.name != &quot;Companion&quot; }</span>
<span class="nc" id="L77">        .mapIndexed { index, field -&gt;</span>
<span class="nc" id="L78">            field.annotations.firstOrNull { it is Column }</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">                ?.let {</span>
<span class="nc" id="L80">                    val col = (it as Column)</span>
<span class="nc bnc" id="L81" title="All 2 branches missed.">                    val index = if (col.position != -1) col.position else index</span>
<span class="nc bnc" id="L82" title="All 2 branches missed.">                    val name = if (col.name != &quot;&quot;) col.name else field.name</span>
<span class="nc" id="L83">                    return@mapIndexed index to ColumnInfo(</span>
<span class="nc" id="L84">                        name,</span>
<span class="nc" id="L85">                        fetchGetter(field.name),</span>
<span class="nc" id="L86">                        fetchSetter(field.name, field.type),</span>
<span class="nc" id="L87">                        createMapper(col.mapper),</span>
<span class="nc" id="L88">                        col.editable</span>
                    )
<span class="nc" id="L90">                } ?: (index to ColumnInfo(field.name, fetchGetter(field.name)))</span>
<span class="nc" id="L91">        }.toMutableList()</span>
<span class="nc" id="L92">        .apply {</span>
<span class="nc" id="L93">            addAll(</span>
<span class="nc" id="L94">                typeInfo.declaredMethods</span>
<span class="nc" id="L95">                    .filter { method -&gt; method.annotations.any { it is Column } }</span>
<span class="nc" id="L96">                    .filter { it.name.startsWith(&quot;get&quot;) }</span>
<span class="nc" id="L97">                    .filter { Modifier.isPublic(it.modifiers) }</span>
<span class="nc" id="L98">                    .mapIndexed { index, method -&gt;</span>
<span class="nc" id="L99">                        method.annotations.firstOrNull { it is Column }</span>
<span class="nc bnc" id="L100" title="All 2 branches missed.">                            ?.let {</span>
<span class="nc" id="L101">                                val col = (it as Column)</span>
<span class="nc bnc" id="L102" title="All 2 branches missed.">                                val index = if (col.position != -1) col.position else index</span>
<span class="nc bnc" id="L103" title="All 2 branches missed.">                                val name = if (col.name != &quot;&quot;) col.name else method.name.replace(&quot;get&quot;, &quot;&quot;)</span>
<span class="nc" id="L104">                                return@mapIndexed index to ColumnInfo(</span>
<span class="nc" id="L105">                                    name,</span>
<span class="nc" id="L106">                                    method,</span>
<span class="nc" id="L107">                                    null,</span>
<span class="nc" id="L108">                                    createMapper(col.mapper),</span>
<span class="nc" id="L109">                                    false</span>
                                )
<span class="nc" id="L111">                            } ?: (index to ColumnInfo(method.name.replace(&quot;get&quot;, &quot;&quot;), method))</span>
                    }
            )
<span class="nc" id="L114">        }.sortedBy { it.first }</span>
<span class="nc" id="L115">        .map { it.second }</span>

    private fun fetchGetter(name: String): Method? {
<span class="nc" id="L118">        return try {</span>
<span class="nc bnc" id="L119" title="All 4 branches missed.">            typeInfo.getMethod(&quot;get&quot; + name.replaceFirstChar {</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">                if (it.isLowerCase()) it.titlecase(</span>
<span class="nc" id="L121">                    getDefault()</span>
<span class="nc" id="L122">                ) else it.toString()</span>
            })
<span class="nc" id="L124">        } catch (_: Exception) {</span>
<span class="nc" id="L125">            null</span>
        }
    }

    private fun fetchSetter(name: String, type: Class&lt;*&gt;): Method? {
<span class="nc" id="L130">        return try {</span>
<span class="nc bnc" id="L131" title="All 4 branches missed.">            typeInfo.getMethod(&quot;set&quot; + name.replaceFirstChar {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">                if (it.isLowerCase()) it.titlecase(</span>
<span class="nc" id="L133">                    getDefault()</span>
<span class="nc" id="L134">                ) else it.toString()</span>
<span class="nc" id="L135">            }, type)</span>
<span class="nc" id="L136">        } catch (_: Exception) {</span>
<span class="nc" id="L137">            null</span>
        }
    }

<span class="nc bnc" id="L141" title="All 2 branches missed.">    override fun getColumnName(column: Int): String = columns.getOrNull(column)?.let {</span>
<span class="nc" id="L142">        return it.name</span>
<span class="nc" id="L143">    } ?: &quot;Unknown Column&quot;</span>

<span class="nc bnc" id="L145" title="All 2 branches missed.">    internal fun isColumnEditable(column: Int): Boolean = columns.getOrNull(column)?.editable ?: false</span>

    override fun isCellEditable(rowIndex: Int, columnIndex: Int): Boolean {
<span class="nc bnc" id="L148" title="All 6 branches missed.">        return isColumnEditable(columnIndex) &amp;&amp; data.size &gt; rowIndex &amp;&amp; rowIndex &gt;= 0</span>
    }

    protected fun setValueOn(obj: T, index: Int, newValue: Any?) {
<span class="nc bnc" id="L152" title="All 4 branches missed.">        val mapper = (columns[index].mapper as? ReadWriteTableValueMapper) ?: return</span>
<span class="nc bnc" id="L153" title="All 2 branches missed.">        if (newValue !is String) return</span>
<span class="nc" id="L154">        val newValue = mapper.mapIn(newValue)</span>
<span class="nc bnc" id="L155" title="All 4 branches missed.">        columns.getOrNull(index)?.setter?.invoke(obj, newValue)</span>
<span class="nc" id="L156">    }</span>

    override fun setValueAt(value: Any?, rowIndex: Int, columnIndex: Int) {
<span class="nc bnc" id="L159" title="All 2 branches missed.">        if (rowIndex &gt;= data.size) {</span>
<span class="nc" id="L160">            return</span>
        }
<span class="nc" id="L162">        setValueOn(data[rowIndex], columnIndex, value)</span>
<span class="nc" id="L163">        super.fireTableCellUpdated(rowIndex, columnIndex)</span>
<span class="nc" id="L164">    }</span>

<span class="nc" id="L166">    override fun getRowCount(): Int = data.size</span>
<span class="nc" id="L167">    override fun getColumnCount(): Int = columns.size</span>
    override fun getValueAt(rowIndex: Int, columnIndex: Int): String {
<span class="nc bnc" id="L169"
      title="All 2 branches missed.">        return columns.getOrNull(columnIndex)?.let {</span>
<span class="nc bnc" id="L170" title="All 4 branches missed.">            val rawValue = it.getter?.invoke(data[rowIndex]) ?: &quot;&quot;</span>
<span class="nc" id="L171">            return it.mapper.mapOut(rawValue)</span>
<span class="nc" id="L172">        } ?: &quot;&quot;</span>
    }

<span class="nc" id="L175">    class ColumnInfo(</span>
<span class="nc" id="L176">        val name: String,</span>
<span class="nc" id="L177">        val getter: Method?,</span>
<span class="nc" id="L178">        val setter: Method? = null,</span>
<span class="nc"
      id="L179">        val mapper: ReadTableValueMapper = createMapper(DefaultReadTableValueMapper::class),</span>
<span class="nc" id="L180">        editable: Boolean = true,</span>
<span class="nc" id="L181">    ) {</span>
<span class="nc bnc" id="L182" title="All 6 branches missed.">        val editable: Boolean = setter != null &amp;&amp; Modifier.isPublic(setter.modifiers) &amp;&amp; editable</span>
    }

    companion object {
        private fun createMapper(mapperClass: KClass&lt;out ReadTableValueMapper&gt;): ReadTableValueMapper =
<span class="nc" id="L187">            mapperClass.java.getConstructor().newInstance() as ReadTableValueMapper</span>
    }
}
</pre>
<div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span>
</div>
</body>
</html>